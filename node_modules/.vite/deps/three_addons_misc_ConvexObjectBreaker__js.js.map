{
  "version": 3,
  "sources": ["../../three/examples/jsm/misc/ConvexObjectBreaker.js"],
  "sourcesContent": ["import {\r\n\tLine3,\r\n\tMesh,\r\n\tPlane,\r\n\tVector3\r\n} from 'three';\r\nimport { ConvexGeometry } from '../geometries/ConvexGeometry.js';\r\n\r\n/**\r\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\r\n *\r\n * Usage:\r\n *\r\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\r\n *\r\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\r\n *\r\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\r\n *\r\n * Requisites for the object:\r\n *\r\n *  - Mesh object must have a buffer geometry and a material\r\n *\r\n *  - Vertex normals must be planar (not smoothed)\r\n *\r\n *  - The geometry must be convex (this is not checked in the library). You can create convex\r\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\r\n *  can also be used.\r\n *\r\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\r\n * Use with caution and read the code when using with other libs.\r\n *\r\n * @param {double} minSizeForBreak Min size a debris can have to break.\r\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\r\n *\r\n*/\r\n\r\nconst _v1 = new Vector3();\r\n\r\nclass ConvexObjectBreaker {\r\n\r\n\tconstructor( minSizeForBreak = 1.4, smallDelta = 0.0001 ) {\r\n\r\n\t\tthis.minSizeForBreak = minSizeForBreak;\r\n\t\tthis.smallDelta = smallDelta;\r\n\r\n\t\tthis.tempLine1 = new Line3();\r\n\t\tthis.tempPlane1 = new Plane();\r\n\t\tthis.tempPlane2 = new Plane();\r\n\t\tthis.tempPlane_Cut = new Plane();\r\n\t\tthis.tempCM1 = new Vector3();\r\n\t\tthis.tempCM2 = new Vector3();\r\n\t\tthis.tempVector3 = new Vector3();\r\n\t\tthis.tempVector3_2 = new Vector3();\r\n\t\tthis.tempVector3_3 = new Vector3();\r\n\t\tthis.tempVector3_P0 = new Vector3();\r\n\t\tthis.tempVector3_P1 = new Vector3();\r\n\t\tthis.tempVector3_P2 = new Vector3();\r\n\t\tthis.tempVector3_N0 = new Vector3();\r\n\t\tthis.tempVector3_N1 = new Vector3();\r\n\t\tthis.tempVector3_AB = new Vector3();\r\n\t\tthis.tempVector3_CB = new Vector3();\r\n\t\tthis.tempResultObjects = { object1: null, object2: null };\r\n\r\n\t\tthis.segments = [];\r\n\t\tconst n = 30 * 30;\r\n\t\tfor ( let i = 0; i < n; i ++ ) this.segments[ i ] = false;\r\n\r\n\t}\r\n\r\n\tprepareBreakableObject( object, mass, velocity, angularVelocity, breakable ) {\r\n\r\n\t\t// object is a Object3d (normally a Mesh), must have a buffer geometry, and it must be convex.\r\n\t\t// Its material property is propagated to its children (sub-pieces)\r\n\t\t// mass must be > 0\r\n\r\n\t\tconst userData = object.userData;\r\n\t\tuserData.mass = mass;\r\n\t\tuserData.velocity = velocity.clone();\r\n\t\tuserData.angularVelocity = angularVelocity.clone();\r\n\t\tuserData.breakable = breakable;\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * @param {int} maxRadialIterations Iterations for radial cuts.\r\n\t * @param {int} maxRandomIterations Max random iterations for not-radial cuts\r\n\t *\r\n\t * Returns the array of pieces\r\n\t */\r\n\tsubdivideByImpact( object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations ) {\r\n\r\n\t\tconst debris = [];\r\n\r\n\t\tconst tempPlane1 = this.tempPlane1;\r\n\t\tconst tempPlane2 = this.tempPlane2;\r\n\r\n\t\tthis.tempVector3.addVectors( pointOfImpact, normal );\r\n\t\ttempPlane1.setFromCoplanarPoints( pointOfImpact, object.position, this.tempVector3 );\r\n\r\n\t\tconst maxTotalIterations = maxRandomIterations + maxRadialIterations;\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tfunction subdivideRadial( subObject, startAngle, endAngle, numIterations ) {\r\n\r\n\t\t\tif ( Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations ) {\r\n\r\n\t\t\t\tdebris.push( subObject );\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet angle = Math.PI;\r\n\r\n\t\t\tif ( numIterations === 0 ) {\r\n\r\n\t\t\t\ttempPlane2.normal.copy( tempPlane1.normal );\r\n\t\t\t\ttempPlane2.constant = tempPlane1.constant;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( numIterations <= maxRadialIterations ) {\r\n\r\n\t\t\t\t\tangle = ( endAngle - startAngle ) * ( 0.2 + 0.6 * Math.random() ) + startAngle;\r\n\r\n\t\t\t\t\t// Rotate tempPlane2 at impact point around normal axis and the angle\r\n\t\t\t\t\tscope.tempVector3_2.copy( object.position ).sub( pointOfImpact ).applyAxisAngle( normal, angle ).add( pointOfImpact );\r\n\t\t\t\t\ttempPlane2.setFromCoplanarPoints( pointOfImpact, scope.tempVector3, scope.tempVector3_2 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tangle = ( ( 0.5 * ( numIterations & 1 ) ) + 0.2 * ( 2 - Math.random() ) ) * Math.PI;\r\n\r\n\t\t\t\t\t// Rotate tempPlane2 at object position around normal axis and the angle\r\n\t\t\t\t\tscope.tempVector3_2.copy( pointOfImpact ).sub( subObject.position ).applyAxisAngle( normal, angle ).add( subObject.position );\r\n\t\t\t\t\tscope.tempVector3_3.copy( normal ).add( subObject.position );\r\n\t\t\t\t\ttempPlane2.setFromCoplanarPoints( subObject.position, scope.tempVector3_3, scope.tempVector3_2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Perform the cut\r\n\t\t\tscope.cutByPlane( subObject, tempPlane2, scope.tempResultObjects );\r\n\r\n\t\t\tconst obj1 = scope.tempResultObjects.object1;\r\n\t\t\tconst obj2 = scope.tempResultObjects.object2;\r\n\r\n\t\t\tif ( obj1 ) {\r\n\r\n\t\t\t\tsubdivideRadial( obj1, startAngle, angle, numIterations + 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( obj2 ) {\r\n\r\n\t\t\t\tsubdivideRadial( obj2, angle, endAngle, numIterations + 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsubdivideRadial( object, 0, 2 * Math.PI, 0 );\r\n\r\n\t\treturn debris;\r\n\r\n\t}\r\n\r\n\tcutByPlane( object, plane, output ) {\r\n\r\n\t\t// Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\r\n\t\t// object2 can be null if the plane doesn't cut the object.\r\n\t\t// object1 can be null only in case of internal error\r\n\t\t// Returned value is number of pieces, 0 for error.\r\n\r\n\t\tconst geometry = object.geometry;\r\n\t\tconst coords = geometry.attributes.position.array;\r\n\t\tconst normals = geometry.attributes.normal.array;\r\n\r\n\t\tconst numPoints = coords.length / 3;\r\n\t\tlet numFaces = numPoints / 3;\r\n\r\n\t\tlet indices = geometry.getIndex();\r\n\r\n\t\tif ( indices ) {\r\n\r\n\t\t\tindices = indices.array;\r\n\t\t\tnumFaces = indices.length / 3;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getVertexIndex( faceIdx, vert ) {\r\n\r\n\t\t\t// vert = 0, 1 or 2.\r\n\r\n\t\t\tconst idx = faceIdx * 3 + vert;\r\n\r\n\t\t\treturn indices ? indices[ idx ] : idx;\r\n\r\n\t\t}\r\n\r\n\t\tconst points1 = [];\r\n\t\tconst points2 = [];\r\n\r\n\t\tconst delta = this.smallDelta;\r\n\r\n\t\t// Reset segments mark\r\n\t\tconst numPointPairs = numPoints * numPoints;\r\n\t\tfor ( let i = 0; i < numPointPairs; i ++ ) this.segments[ i ] = false;\r\n\r\n\t\tconst p0 = this.tempVector3_P0;\r\n\t\tconst p1 = this.tempVector3_P1;\r\n\t\tconst n0 = this.tempVector3_N0;\r\n\t\tconst n1 = this.tempVector3_N1;\r\n\r\n\t\t// Iterate through the faces to mark edges shared by coplanar faces\r\n\t\tfor ( let i = 0; i < numFaces - 1; i ++ ) {\r\n\r\n\t\t\tconst a1 = getVertexIndex( i, 0 );\r\n\t\t\tconst b1 = getVertexIndex( i, 1 );\r\n\t\t\tconst c1 = getVertexIndex( i, 2 );\r\n\r\n\t\t\t// Assuming all 3 vertices have the same normal\r\n\t\t\tn0.set( normals[ a1 ], normals[ a1 ] + 1, normals[ a1 ] + 2 );\r\n\r\n\t\t\tfor ( let j = i + 1; j < numFaces; j ++ ) {\r\n\r\n\t\t\t\tconst a2 = getVertexIndex( j, 0 );\r\n\t\t\t\tconst b2 = getVertexIndex( j, 1 );\r\n\t\t\t\tconst c2 = getVertexIndex( j, 2 );\r\n\r\n\t\t\t\t// Assuming all 3 vertices have the same normal\r\n\t\t\t\tn1.set( normals[ a2 ], normals[ a2 ] + 1, normals[ a2 ] + 2 );\r\n\r\n\t\t\t\tconst coplanar = 1 - n0.dot( n1 ) < delta;\r\n\r\n\t\t\t\tif ( coplanar ) {\r\n\r\n\t\t\t\t\tif ( a1 === a2 || a1 === b2 || a1 === c2 ) {\r\n\r\n\t\t\t\t\t\tif ( b1 === a2 || b1 === b2 || b1 === c2 ) {\r\n\r\n\t\t\t\t\t\t\tthis.segments[ a1 * numPoints + b1 ] = true;\r\n\t\t\t\t\t\t\tthis.segments[ b1 * numPoints + a1 ] = true;\r\n\r\n\t\t\t\t\t\t}\telse {\r\n\r\n\t\t\t\t\t\t\tthis.segments[ c1 * numPoints + a1 ] = true;\r\n\t\t\t\t\t\t\tthis.segments[ a1 * numPoints + c1 ] = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\telse if ( b1 === a2 || b1 === b2 || b1 === c2 ) {\r\n\r\n\t\t\t\t\t\tthis.segments[ c1 * numPoints + b1 ] = true;\r\n\t\t\t\t\t\tthis.segments[ b1 * numPoints + c1 ] = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Transform the plane to object local space\r\n\t\tconst localPlane = this.tempPlane_Cut;\r\n\t\tobject.updateMatrix();\r\n\t\tConvexObjectBreaker.transformPlaneToLocalSpace( plane, object.matrix, localPlane );\r\n\r\n\t\t// Iterate through the faces adding points to both pieces\r\n\t\tfor ( let i = 0; i < numFaces; i ++ ) {\r\n\r\n\t\t\tconst va = getVertexIndex( i, 0 );\r\n\t\t\tconst vb = getVertexIndex( i, 1 );\r\n\t\t\tconst vc = getVertexIndex( i, 2 );\r\n\r\n\t\t\tfor ( let segment = 0; segment < 3; segment ++ ) {\r\n\r\n\t\t\t\tconst i0 = segment === 0 ? va : ( segment === 1 ? vb : vc );\r\n\t\t\t\tconst i1 = segment === 0 ? vb : ( segment === 1 ? vc : va );\r\n\r\n\t\t\t\tconst segmentState = this.segments[ i0 * numPoints + i1 ];\r\n\r\n\t\t\t\tif ( segmentState ) continue; // The segment already has been processed in another face\r\n\r\n\t\t\t\t// Mark segment as processed (also inverted segment)\r\n\t\t\t\tthis.segments[ i0 * numPoints + i1 ] = true;\r\n\t\t\t\tthis.segments[ i1 * numPoints + i0 ] = true;\r\n\r\n\t\t\t\tp0.set( coords[ 3 * i0 ], coords[ 3 * i0 + 1 ], coords[ 3 * i0 + 2 ] );\r\n\t\t\t\tp1.set( coords[ 3 * i1 ], coords[ 3 * i1 + 1 ], coords[ 3 * i1 + 2 ] );\r\n\r\n\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\r\n\t\t\t\tlet mark0 = 0;\r\n\r\n\t\t\t\tlet d = localPlane.distanceToPoint( p0 );\r\n\r\n\t\t\t\tif ( d > delta ) {\r\n\r\n\t\t\t\t\tmark0 = 2;\r\n\t\t\t\t\tpoints2.push( p0.clone() );\r\n\r\n\t\t\t\t} else if ( d < - delta ) {\r\n\r\n\t\t\t\t\tmark0 = 1;\r\n\t\t\t\t\tpoints1.push( p0.clone() );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmark0 = 3;\r\n\t\t\t\t\tpoints1.push( p0.clone() );\r\n\t\t\t\t\tpoints2.push( p0.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\r\n\t\t\t\tlet mark1 = 0;\r\n\r\n\t\t\t\td = localPlane.distanceToPoint( p1 );\r\n\r\n\t\t\t\tif ( d > delta ) {\r\n\r\n\t\t\t\t\tmark1 = 2;\r\n\t\t\t\t\tpoints2.push( p1.clone() );\r\n\r\n\t\t\t\t} else if ( d < - delta ) {\r\n\r\n\t\t\t\t\tmark1 = 1;\r\n\t\t\t\t\tpoints1.push( p1.clone() );\r\n\r\n\t\t\t\t}\telse {\r\n\r\n\t\t\t\t\tmark1 = 3;\r\n\t\t\t\t\tpoints1.push( p1.clone() );\r\n\t\t\t\t\tpoints2.push( p1.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ( mark0 === 1 && mark1 === 2 ) || ( mark0 === 2 && mark1 === 1 ) ) {\r\n\r\n\t\t\t\t\t// Intersection of segment with the plane\r\n\r\n\t\t\t\t\tthis.tempLine1.start.copy( p0 );\r\n\t\t\t\t\tthis.tempLine1.end.copy( p1 );\r\n\r\n\t\t\t\t\tlet intersection = new Vector3();\r\n\t\t\t\t\tintersection = localPlane.intersectLine( this.tempLine1, intersection );\r\n\r\n\t\t\t\t\tif ( intersection === null ) {\r\n\r\n\t\t\t\t\t\t// Shouldn't happen\r\n\t\t\t\t\t\tconsole.error( 'Internal error: segment does not intersect plane.' );\r\n\t\t\t\t\t\toutput.segmentedObject1 = null;\r\n\t\t\t\t\t\toutput.segmentedObject2 = null;\r\n\t\t\t\t\t\treturn 0;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpoints1.push( intersection );\r\n\t\t\t\t\tpoints2.push( intersection.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Calculate debris mass (very fast and imprecise):\r\n\t\tconst newMass = object.userData.mass * 0.5;\r\n\r\n\t\t// Calculate debris Center of Mass (again fast and imprecise)\r\n\t\tthis.tempCM1.set( 0, 0, 0 );\r\n\t\tlet radius1 = 0;\r\n\t\tconst numPoints1 = points1.length;\r\n\r\n\t\tif ( numPoints1 > 0 ) {\r\n\r\n\t\t\tfor ( let i = 0; i < numPoints1; i ++ ) this.tempCM1.add( points1[ i ] );\r\n\r\n\t\t\tthis.tempCM1.divideScalar( numPoints1 );\r\n\t\t\tfor ( let i = 0; i < numPoints1; i ++ ) {\r\n\r\n\t\t\t\tconst p = points1[ i ];\r\n\t\t\t\tp.sub( this.tempCM1 );\r\n\t\t\t\tradius1 = Math.max( radius1, p.x, p.y, p.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.tempCM1.add( object.position );\r\n\r\n\t\t}\r\n\r\n\t\tthis.tempCM2.set( 0, 0, 0 );\r\n\t\tlet radius2 = 0;\r\n\t\tconst numPoints2 = points2.length;\r\n\t\tif ( numPoints2 > 0 ) {\r\n\r\n\t\t\tfor ( let i = 0; i < numPoints2; i ++ ) this.tempCM2.add( points2[ i ] );\r\n\r\n\t\t\tthis.tempCM2.divideScalar( numPoints2 );\r\n\t\t\tfor ( let i = 0; i < numPoints2; i ++ ) {\r\n\r\n\t\t\t\tconst p = points2[ i ];\r\n\t\t\t\tp.sub( this.tempCM2 );\r\n\t\t\t\tradius2 = Math.max( radius2, p.x, p.y, p.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.tempCM2.add( object.position );\r\n\r\n\t\t}\r\n\r\n\t\tlet object1 = null;\r\n\t\tlet object2 = null;\r\n\r\n\t\tlet numObjects = 0;\r\n\r\n\t\tif ( numPoints1 > 4 ) {\r\n\r\n\t\t\tobject1 = new Mesh( new ConvexGeometry( points1 ), object.material );\r\n\t\t\tobject1.position.copy( this.tempCM1 );\r\n\t\t\tobject1.quaternion.copy( object.quaternion );\r\n\r\n\t\t\tthis.prepareBreakableObject( object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak );\r\n\r\n\t\t\tnumObjects ++;\r\n\r\n\t\t}\r\n\r\n\t\tif ( numPoints2 > 4 ) {\r\n\r\n\t\t\tobject2 = new Mesh( new ConvexGeometry( points2 ), object.material );\r\n\t\t\tobject2.position.copy( this.tempCM2 );\r\n\t\t\tobject2.quaternion.copy( object.quaternion );\r\n\r\n\t\t\tthis.prepareBreakableObject( object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak );\r\n\r\n\t\t\tnumObjects ++;\r\n\r\n\t\t}\r\n\r\n\t\toutput.object1 = object1;\r\n\t\toutput.object2 = object2;\r\n\r\n\t\treturn numObjects;\r\n\r\n\t}\r\n\r\n\tstatic transformFreeVector( v, m ) {\r\n\r\n\t\t// input:\r\n\t\t// vector interpreted as a free vector\r\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\r\n\r\n\t\tconst x = v.x, y = v.y, z = v.z;\r\n\t\tconst e = m.elements;\r\n\r\n\t\tv.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\r\n\t\tv.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\r\n\t\tv.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\t\treturn v;\r\n\r\n\t}\r\n\r\n\tstatic transformFreeVectorInverse( v, m ) {\r\n\r\n\t\t// input:\r\n\t\t// vector interpreted as a free vector\r\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\r\n\r\n\t\tconst x = v.x, y = v.y, z = v.z;\r\n\t\tconst e = m.elements;\r\n\r\n\t\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;\r\n\t\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z;\r\n\t\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z;\r\n\r\n\t\treturn v;\r\n\r\n\t}\r\n\r\n\tstatic transformTiedVectorInverse( v, m ) {\r\n\r\n\t\t// input:\r\n\t\t// vector interpreted as a tied (ordinary) vector\r\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\r\n\r\n\t\tconst x = v.x, y = v.y, z = v.z;\r\n\t\tconst e = m.elements;\r\n\r\n\t\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z - e[ 12 ];\r\n\t\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z - e[ 13 ];\r\n\t\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z - e[ 14 ];\r\n\r\n\t\treturn v;\r\n\r\n\t}\r\n\r\n\tstatic transformPlaneToLocalSpace( plane, m, resultPlane ) {\r\n\r\n\t\tresultPlane.normal.copy( plane.normal );\r\n\t\tresultPlane.constant = plane.constant;\r\n\r\n\t\tconst referencePoint = ConvexObjectBreaker.transformTiedVectorInverse( plane.coplanarPoint( _v1 ), m );\r\n\r\n\t\tConvexObjectBreaker.transformFreeVectorInverse( resultPlane.normal, m );\r\n\r\n\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\r\n\t\tresultPlane.constant = - referencePoint.dot( resultPlane.normal );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { ConvexObjectBreaker };\r\n"],
  "mappings": "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",
  "names": []
}
